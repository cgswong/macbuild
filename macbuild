#!/usr/bin/env bash
# macOS system configuration and package management tool
# Installs packages via Homebrew, Python (uv), Node (pnpm), Ruby (gem), and mise

# TODO: Uncomment after resolving pipeline issues.
# set -euo pipefail  # Exit on error, undefined vars, pipe failures

# -- Configuration --
readonly SCRIPT_NAME=${0##*/}
readonly SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
readonly SCRIPT_HOME="$SCRIPT_DIR"
readonly SCRIPT_VERSION="2.0.0"

# Environment variables with defaults
LOG_LEVEL=${LOG_LEVEL:-"INFO"}
LOG_DIR=${LOG_DIR:-"~/.${SCRIPT_NAME}/logs"}
PKG_FILE=${PKG_FILE:-"${SCRIPT_HOME}/files/packages.ini"}

# Derived paths
readonly LOG_FILE="${LOG_DIR}/${SCRIPT_NAME%.*}.log"
readonly OS_UPDATE_FILE="com.user.macbuild_update.plist"
readonly OS_UPDATE_PATH="${HOME}/Library/LaunchAgents"

# -- Logging functions --

# Initialize log directory and file
setup_logging() {
  [[ ! -d "$LOG_DIR" ]] && mkdir -p "$LOG_DIR"
  touch "$LOG_FILE" || {
    printf "ERROR: Cannot create log file %s\n" "$LOG_FILE" >&2
    exit 1
  }
}

# Log messages with timestamp, level, and color coding
log_message() {
  local level="$1"
  local message="$2"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

  # Always log to file
  printf "%s [%s] %s\n" "$timestamp" "$level" "$message" >> "$LOG_FILE"

  # Console output with color coding
  case "$level" in
    ERROR)
      printf "\033[31m%s [ERROR] %s\033[0m\n" "$timestamp" "$message" >&2 ;;
    WARN)
      printf "\033[33m%s [WARN] %s\033[0m\n" "$timestamp" "$message" >&2 ;;
    INFO)
      printf "%s [INFO] %s\n" "$timestamp" "$message" ;;
    DEBUG)
      [[ "$LOG_LEVEL" == "DEBUG" ]] && printf "%s [DEBUG] %s\n" "$timestamp" "$message" ;;
  esac
}

# -- Utility functions --

# Check if command exists in PATH
command_exists() {
  command -v "$1" &>/dev/null
}

# Verify file exists and is readable
check_file_readable() {
  [[ -r "$1" ]] || {
    log_message "ERROR" "File not readable: $1"
    return 1
  }
}

# Execute command with retry logic for network operations
run_with_retry() {
  local cmd="$1"
  local max_attempts="${2:-3}"

  for ((attempt=1; attempt<=max_attempts; attempt++)); do
    log_message "DEBUG" "Attempt $attempt: $cmd"
    if eval "$cmd"; then
      return 0
    fi
    [[ $attempt -lt $max_attempts ]] && {
      log_message "WARN" "Command failed, retrying in 2 seconds (attempt $attempt/$max_attempts)"
      sleep 2
    }
  done

  log_message "ERROR" "Command failed after $max_attempts attempts: $cmd"
  return 1
}

# -- Help and version --

# Display version information
print_version() {
  printf "%s %s\n" "$SCRIPT_NAME" "$SCRIPT_VERSION"
}

# Display usage instructions and available options
print_usage() {
  cat <<-DESC
Install tools and configure macOS. Services used include: Homebrew, pnpm (Node.JS), uv (Python), gem (Ruby), and mise.

Usage: ${SCRIPT_NAME} [options]

Options:
  -h, --help              Show this help message
  --version               Show version information
  --log-level LEVEL       Set logging level (DEBUG|INFO|WARN|ERROR)
  --update-only           Update existing tools only
  --install TYPE          Install specific package type
                         (brew | apps | python | node | ruby | mise | all)

Environment Variables:
  LOG_LEVEL              Logging level (default: INFO)
  LOG_DIR                Log directory (default: ~/.macbuild/logs)
  PKG_FILE               Package configuration file

Examples:
  macbuild                        # Full installation
  macbuild --update-only          # Update existing packages
  macbuild --install python       # Install Python packages only
  LOG_LEVEL=DEBUG macbuild        # Enable debug logging
DESC
}

# -- Package management --

# Parse INI file sections to extract package lists
parse_ini_section() {
  local section="$1"
  local file="$PKG_FILE"

  check_file_readable "$file" || return 1

  awk -v section="$section" '
      /^[ \t]*#/ { next }
      /^[ \t]*$/ { next }
      /^\[.*\]$/ {
          gsub(/^\[|\]$/, "")
          current = $0
          found = (current == section)
          next
      }
      found && NF >= 1 { print $1 }
  ' "$file"
}

# Install or update Homebrew package manager
setup_homebrew() {
  if command_exists brew; then
    log_message "INFO" "Updating Homebrew"
    run_with_retry "brew update && brew upgrade"
  else
    log_message "INFO" "Installing Homebrew"
    run_with_retry '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
  fi
}

# Install Xcode command line tools if not present
install_xcode_tools() {
  if [[ -f "/Library/Developer/CommandLineTools/usr/bin/clang" ]]; then
    log_message "INFO" "Xcode command line tools already installed"
    return 0
  fi

  log_message "INFO" "Installing Xcode command line tools"
  if xcode-select --install; then
    log_message "INFO" "Xcode command line tools installed successfully"
  else
    log_message "ERROR" "Failed to install Xcode command line tools"
    return 1
  fi
}

# Install Python packages using uv tool manager
install_python_packages() {
  command_exists uv || {
    log_message "WARN" "uv not available, skipping Python packages"
    return 0
  }

  check_file_readable "$PKG_FILE" || return 1

  log_message "INFO" "Installing Python packages"
  for package in $(parse_ini_section "python"); do
    log_message "DEBUG" "Installing Python package: $package"
    run_with_retry "uv tool install --upgrade --quiet $package"
  done
}

# Install Homebrew packages (formulae)
install_homebrew_packages() {
  local section="$1"

  command_exists brew || {
    log_message "ERROR" "Homebrew not available"
    return 1
  }

  check_file_readable "$PKG_FILE" || return 1

  log_message "INFO" "Installing $section packages"
  for package in $(parse_ini_section "$section"); do
    log_message "DEBUG" "Installing $section package: $package"
    run_with_retry "brew install --quiet $package"
  done
}

# Install Homebrew apps (casks)
install_homebrew_apps() {
  local section="$1"

  command_exists brew || {
    log_message "ERROR" "Homebrew not available"
    return 1
  }

  check_file_readable "$PKG_FILE" || return 1

  log_message "INFO" "Installing $section packages"
  for package in $(parse_ini_section "$section"); do
    log_message "DEBUG" "Installing $section package: $package"
    run_with_retry "brew install --cask --quiet $package"
  done
}

# Install Node.js packages using pnpm
install_node_packages() {
  command_exists pnpm || {
    log_message "WARN" "pnpm not available, skipping Node packages"
    return 0
  }

  check_file_readable "$PKG_FILE" || return 1

  log_message "INFO" "Installing Node packages"
  for package in $(parse_ini_section "node"); do
    log_message "DEBUG" "Installing Node package: $package"
    run_with_retry "pnpm install $package"
    # TODO: Enable on the global bin directory is setup after `pnpm setup`
    # run_with_retry "pnpm install -g $package"
  done
}

# Install Ruby gems using gem
install_ruby_packages() {
  command_exists gem || {
    log_message "WARN" "gem not available, skipping Ruby packages"
    return 0
  }

  check_file_readable "$PKG_FILE" || return 1

  log_message "INFO" "Installing Ruby packages"
  for package in $(parse_ini_section "gem"); do
    log_message "DEBUG" "Installing Ruby package: $package"
    run_with_retry "gem install $package"
  done
}

# Install development tools using mise
install_mise_packages() {
  command_exists mise || {
    log_message "WARN" "mise not available, skipping mise packages"
    return 0
  }

  check_file_readable "$PKG_FILE" || return 1

  log_message "INFO" "Installing mise packages"
  for package in $(parse_ini_section "mise"); do
    log_message "DEBUG" "Installing mise package: $package"
    run_with_retry "mise use --global $package"
  done
}

# Update macOS
update_macos() {
  log_message "INFO" "Checking for macOS updates"

  # Check if updates are available first
  if ! softwareupdate -l &>/dev/null; then
    log_message "INFO" "No macOS updates available"
    return 0
  fi

  log_message "INFO" "Installing macOS updates (may require restart)"
  setup_sudo_access
  if sudo softwareupdate --agree-to-license --install --all --restart; then
    log_message "INFO" "macOS updates installed successfully"
  else
    log_message "ERROR" "Failed to install macOS updates"
    return 1
  fi
}

# -- Update functions --

# Update all installed package managers and their packages
update_all_tools() {
  log_message "INFO" "Starting system updates"

  setup_homebrew || true

  command_exists pnpm && {
    log_message "INFO" "Updating Node packages"
    run_with_retry "pnpm update --global" || true
  }

  command_exists uv && {
    log_message "INFO" "Updating Python packages"
    run_with_retry "uv tool upgrade --all --reinstall --quiet" || true
  }

  command_exists mise && {
    log_message "INFO" "Updating mise packages"
    run_with_retry "mise upgrade" || true
  }

  log_message "INFO" "Updating macOS"
  update_macos || true

  log_message "INFO" "System updates completed"
}

# Configure launchd for automatic system updates
setup_auto_updates() {
  local plist_source="${SCRIPT_HOME}/files/${OS_UPDATE_FILE}"
  local plist_dest="${OS_UPDATE_PATH}/${OS_UPDATE_FILE}"

  check_file_readable "$plist_source" || {
    log_message "WARN" "Auto-update plist not found: $plist_source"
    return 1
  }

  log_message "INFO" "Setting up automatic updates"
  [[ ! -d "$OS_UPDATE_PATH" ]] && mkdir -p "$OS_UPDATE_PATH"

  cp "$plist_source" "$plist_dest" && \
  chmod 644 "$plist_dest" && \
  launchctl unload "$plist_dest" 2>/dev/null || true && \
  launchctl load "$plist_dest"
}

# Setup persistent sudo access for command executions
setup_sudo_access() {
  log_message INFO "Checking for SUDO password and updating timestamp until we are finished."
  sudo -v
  while true; do
    sudo -n true
    sleep 60
    kill -0 "$" || exit
  done 2>/dev/null &
  SUDO_REFRESH_PID=$!

  # Ensure we kill the sudo refresh process on exit
  trap 'kill $SUDO_REFRESH_PID 2>/dev/null || true' EXIT
}

# -- Main installation functions --

# Route installation to appropriate package manager based on type
install_package_type() {
  case "$1" in
    brew)
      install_homebrew_packages "homebrew"
      ;;
    apps)
      install_homebrew_apps "cask"
      ;;
    python)
      install_python_packages
      ;;
    node)
      install_node_packages
      ;;
    ruby)
      install_ruby_packages
      ;;
    mise)
      install_mise_packages
      ;;
    all)
      install_homebrew_packages "homebrew"
      install_homebrew_apps "cask"
      install_python_packages
      install_node_packages
      install_ruby_packages
      install_mise_packages
      ;;
    *)
      log_message "ERROR" "Unknown package type: $1"
      return 1
      ;;
  esac
}

# -- Main execution --

# Main function - orchestrates the entire installation process
main() {
  local update_only=false
  local install=""

  # Parse command line arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        print_usage; exit 0 ;;
      --version)
        print_version; exit 0 ;;
      --log-level)
        [[ -n "${2:-}" ]] || { log_message "ERROR" "--log-level requires an argument"; exit 1; }
        LOG_LEVEL="$2"; shift 2 ;;
      --log-level=*)
        LOG_LEVEL="${1#*=}"; shift ;;
      --update-only)
        update_only=true; shift ;;
      --install)
        [[ -n "${2:-}" ]] || { log_message "ERROR" "--install requires an argument"; exit 1; }
        install="$2"; shift 2 ;;
      --install=*)
        install="${1#*=}"; shift ;;
      -*)
        log_message "ERROR" "Unknown option: $1"; print_usage >&2; exit 1 ;;
      *)
        log_message "ERROR" "Unexpected argument: $1"; print_usage >&2; exit 1 ;;
    esac
  done

  # Initialize logging system
  setup_logging
  log_message "INFO" "Starting $SCRIPT_NAME v$SCRIPT_VERSION"

  # Handle update-only mode - skip installation, just update existing packages
  if [[ "$update_only" == true ]]; then
    log_message "INFO" "Running in update-only mode"
    update_all_tools
    log_message "INFO" "Update completed successfully"
    exit 0
  fi

  # Main installation workflow
  install_xcode_tools || { log_message "ERROR" "Failed to install Xcode tools"; exit 1; }
  setup_homebrew || { log_message "ERROR" "Failed to setup Homebrew"; exit 1; }
  setup_auto_updates

  # Install packages based on user selection or install all
  if [[ -n "$install" ]]; then
    log_message "INFO" "Installing package type: $install"
    install_package_type "$install"
  else
    log_message "INFO" "Installing all package types"
    install_package_type "all"
  fi

  log_message "INFO" "Installation completed successfully"
}

# Execute main function with all command line arguments
main "$@"
